<!DOCTYPE html>
<html>
<head>
  <title>migi</title>
  <meta charset="UTF-8"/>
  <style>
    ol span{
      font-size:12px;
      line-height:18px;
      text-shadow:1px 1px 2px rgba(0,0,0, 0.1);
    }
    ol a{
      color:#39F;
      text-shadow:1px 1px 2px rgba(0,0,0, 0.1);
      text-decoration:none;
    }
    ol a:hover{
      color:#F30;
    }
  </style>
</head>
<body>
<ol>
  <li>
    <a href="hello.html" title="hello">Hello World!</a>
    <span>基本的render方法接收2个参数：模板和渲染对象</span>
  </li>
  <li>
    <a href="jsx.html" title="jsx">JSX</a>
    <span>jsx语法允许html和js混写，这是facebook发明的规范</span>
  </li>
  <li>
    <a href="array.html" title="array">展开数组</a>
    <span>当jsx变量遇到数组时，会自动遍历每项，这是个递归的过程</span>
  </li>
  <li>
    <a href="rest.html" title="rest">扩展参数</a>
    <span>属性支持传入rest参数，将自动展开对象</span>
  </li>
  <li>
    <a href="encode.html" title="encode">转义编码</a>
    <span>所有文本变量都会被自动转义，如果想避免，请使用dangerouslySetInnerHTML设置属性</span>
  </li>
  <li>
    <a href="component.html" title="component">自定义组件</a>
    <span>当jsx中的html的tagName为一个继承自migi.Component的类时，将生产一个组件类的实例，并调用其render()方法渲染。它的props属性为第1个参数，来自于attribute</span>
  </li>
  <li>
    <a href="template.html" title="template">作为普通模板</a>
    <span>一个自定义组件或jsx的模板对象，因为覆写了toString()方法，所以可以作为一个String类型被使用</span>
  </li>
  <li>
    <a href="children.html" title="children">children属性</a>
    <span>自定义组件拥有children属性，是个数组，指向实际运行时其html的孩子节点</span>
  </li>
  <li>
    <a href="shadow.html" title="shadow">shadow作用域隔离</a>
    <span>如同WebComponent一样，组件内的事件是不向外冒泡的，但这并不能阻止捕获。在下面的css组件中，如果使用了jaw构建，css也将shadow化</span>
  </li>
  <li>
    <a href="allow.html" title="shadow">allowPropagation</a>
    <span>如果组件声明了allowPropagation，那么事件则可冒泡</span>
  </li>
  <li>
    <a href="find.html" title="dom">find</a>
    <span>find和findAll寻找VirtualDom下的孩子（们），支持当前浏览器默认的选择器；findChild和findChildren则寻找参数下的孩子（们），只支持name</span>
  </li>
  <li>
    <a href="fake.html" title="dom">DOM事件和fake</a>
    <span>组件和vd被添加到DOM上时，会触发Event.DOM事件；当没覆写render方法时其子节点会被作为children渲染添加到DOM上，否则并没有，此时也有DOM事件但第一个参数fake为true表明是假的</span>
  </li>
  <li>
    <a href="dom.html" title="dom">侦听操作DOM</a>
    <span>当渲染完毕时，自定义组件拥有element对象指向其根节点DOM，即render()方法的根节点</span>
  </li>
  <li>
    <a href="pt.html" title="parent&top">parent&top</a>
    <span>VirtualDom和Component都拥有parent&top引用，可访问父级和最近的顶级组件</span>
  </li>
  <li>
    <a href="ref.html" title="ref">ref引用</a>
    <span>组件还可以通过ref快速访问VirtualDom的引用</span>
  </li>
  <li>
    <a href="event.html" title="event">事件绑定</a>
    <span>vd或组件采用onXxx语法绑定事件，并且this指向当前对象；示例中有个活用bind更改this的示范</span>
  </li>
  <li>
    <a href="delegate.html" title="delegate">事件代理</a>
    <span>你可能想采用类似jquery的on或delegate来提升事件性能，migi也实现了类似功能，并且采用类似选择器预编译解析的方式使得体积和性能都提升很多</span>
  </li>
  <li>
    <a href="unidirectional.html" title="unidirectional">get/set单向数据绑定</a>
    <span>自定义组件类中声明了get/set方法的变量，在render()中渲染将产生数据绑定，一旦发生改变，会联动</span>
  </li>
  <li>
    <a href="bidirectional.html" title="bidirectional">get/set双向数据绑定</a>
    <span>同上，只是view层发生改变时model层同步</span>
  </li>
  <li>
    <a href="explicit.html" title="explicit">显式声明绑定</a>
    <span>可能有get没set或者mv和m层数据分开的原因，可为get方法的形参追加变量名，显示声明绑定哪个变量</span>
  </li>
  <li>
    <a href="ajax.html" title="ajax">Ajax非可视组件</a>
    <span>当一个自定义组件无需DOM时，可继承NonVisualComponent，它render()返回空字符串</span>
  </li>
  <li>
    <a href="texta.html" title="texta">文字动画</a>
    <span>展示了如何用数据绑定来实现动画的效果</span>
  </li>
  <li>
    <a href="cache.html" title="cache">继承缓存组件</a>
    <span>绑定数据频繁操作时会引发大量重绘，此时继承CacheComponent是个很好的选择，它将缓存结果只渲染1次</span>
  </li>
  <li>
    <a href="flush.html" title="flush">清空缓存</a>
    <span>如果有特定需求，想对缓存数据渲染进行同步调用，可以使用flush()方法</span>
  </li>
  <li>
    <a href="expr.html" title="expr">任意js表达式数据都被侦听</a>
    <span>jsx中的js表达式包含的绑定变量可能不止1个</span>
  </li>
  <li>
    <a href="add.html" title="add">添加删除元素</a>
    <span>演示了各种情况，更新DOM和文本节点。get/set的对象是个引用时需重新自己赋值一下</span>
  </li>
  <li>
    <a href="domdiff.html" title="domdiff">DomDiff</a>
    <span>利用虚拟DOM比对来提升性能</span>
  </li>
  <li>
    <a href="switch.html" title="switch">切换按钮</a>
    <span>一个Switch的示例</span>
  </li>
  <li>
    <a href="style.html" title="style">css组件</a>
    <span>将Switch用到的css用jaw解析进来形成单一静态资源文件</span>
  </li>
  <li>
    <a href="pseudo.html" title="pseudo">伪类</a>
    <span>也支持css2的伪类</span>
  </li>
  <li>
    <a href="attr.html" title="attr">属性</a>
    <span>也支持css2的属性，建议组件使用单层级class，从性能上考虑</span>
  </li>
  <li>
    <a href="exclusive.html" title="exclusive">不排他</a>
    <span>自定义组件示例对象可以单独使用，作为一个普通js对象</span>
  </li>
  <li>
    <a href="select.html" title="select">下拉菜单</a>
    <span>这是一个模拟下拉菜单的组件，它通过前面的Ajax组件读取一个数据源并进行展示</span>
  </li>
  <li>
    <a href="bridge.html" title="bridge">数据桥接bridge</a>
    <span>这是联动下拉菜单的组件，它通过前面的Ajax组件读取一个省市信息展示，使用bridge进行桥接单向数据联动、middleware进行数据处理</span>
  </li>
  <li>
    <a href="bridgee.html" title="bridge">数据中转事件总线</a>
    <span>虽然用find方法可以找到若干个组件进行数据联动，但毕竟不方便。migi.eventBus作为事件总线外，还可以用作数据中转站，同样的bridge接口串联2个组件数据</span>
  </li>
  <li>
    <a href="tap.html" title="bridge">tap事件</a>
    <span>类似zepto的tap事件，实际上是转换成click，对于延迟处理，已内置fastclick库。对于包括document.body在内的每个隔离作用域的组件，都会应用之</span>
  </li>
  <li>
    <a href="touch.html" title="touch">基本touch手势</a>
    <span>改写自zepto的touch库，内置了doubleTap、longTap、swipe、swipeUp、swipeRight、swipeDown、swipeLeft事件</span>
  </li>
  <li>
    <a href="model.html" title="model">Model数据模型</a>
    <span>可以为组件赋值model属性为一个数据模型对象，这样更有利于专门的数据管理，它也可以通过model标签赋值给组件</span>
  </li>
  <li>
    <a href="modelbridge.html" title="modelbridge">Model桥接</a>
    <span>Model对象可以和组件对象一样，互相bridge桥接，甚至桥接EventBus</span>
  </li>
  <li>
    <a href="models.html" title="models">共用Model</a>
    <span>任意多个组件，可共享一个Model对象，如此实现多个组件一份数据</span>
  </li>
  <li>
    <a href="lie.html" title="bridge">ie8的get/set hack</a>
    <span>ie8由于浏览器限制，无法为普通js对象提供get/set，故使用了hack手段让组件返回的是个DOM对象。此时判别对象类型和使用引用时会有陷阱，故提供了个兼容的$引用来读取/设置组件get/set属性，而$$则返回原组件对象引用</span>
  </li>
  <li>
    <a href="benchmark.html" title="benchmark">性能测试</a>
    <span><a href="http://leeluolee.github.io/js-repaint-perfs/" target="_blank">http://leeluolee.github.io/js-repaint-perfs/</a></span>
  </li>
</ol>
<p><a href="https://github.com/migijs/migi" target="_blank" title="github">github source</a></p>
</body>
</html>