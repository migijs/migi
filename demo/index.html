<!DOCTYPE html>
<html>
<head>
  <title>migi</title>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"/>
  <style>
    ol span{
      font-size:12px;
      line-height:18px;
      text-shadow:1px 1px 2px rgba(0,0,0, 0.1);
    }
    ol a{
      color:#39F;
      text-shadow:1px 1px 2px rgba(0,0,0, 0.1);
      text-decoration:none;
    }
    ol a:hover{
      color:#F30;
    }
  </style>
</head>
<body>
<ol>
  <li>
    <a href="hello.html" title="hello">Hello World!</a>
    <span>基本的render方法接收2个参数：模板和渲染对象</span>
  </li>
  <li>
    <a href="jsx.html" title="jsx">JSX</a>
    <span>jsx语法允许html和js混写，这是facebook发明的规范</span>
  </li>
  <li>
    <a href="array.html" title="array">展开数组</a>
    <span>当jsx变量遇到数组时，会自动遍历每项，这是个递归的过程</span>
  </li>
  <li>
    <a href="rest.html" title="rest">扩展参数</a>
    <span>属性支持传入rest参数，将自动展开对象</span>
  </li>
  <li>
    <a href="encode.html" title="encode">转义编码</a>
    <span>所有文本变量都会被自动转义，如果想避免，请使用dangerouslySetInnerHTML设置属性</span>
  </li>
  <li>
    <a href="component.html" title="component">自定义组件</a>
    <span>当jsx中的html的tagName为一个继承自migi.Component的类时，将生产一个组件类的实例，并调用其render()方法渲染。它的props属性为第1个参数，来自于attribute</span>
  </li>
  <li>
    <a href="template.html" title="template">作为普通模板</a>
    <span>一个自定义组件或jsx的模板对象，因为覆写了toString()方法，所以可以作为一个String类型被使用</span>
  </li>
  <li>
    <a href="children.html" title="children">children属性</a>
    <span>自定义组件拥有children属性，是个数组，指向实际运行时其html的孩子节点</span>
  </li>
  <li>
    <a href="shadow.html" title="shadow">shadow作用域隔离</a>
    <span>如同WebComponent一样，如果组件声明了stopPropagation为true，组件内的事件是不向外冒泡的，但这并不能阻止捕获。在下面的css组件中，如果使用了jaw构建，css也将shadow化</span>
  </li>
  <li>
    <a href="allow.html" title="shadow">stopPropagation</a>
    <span>如果组件声明了stopPropagation为false（默认值），那么所有事件可以冒泡。注意DOM属性优先级大于js属性优先级</span>
  </li>
  <li>
    <a href="domready.html" title="domReady">domReady事件</a>
    <span>组件和vd被migi.render()方法添加到DOM上时，会触发Event.DOM事件</span>
  </li>
  <li>
    <a href="find.html" title="dom">find</a>
    <span>find和findAll寻找VirtualDom下的孩子（们），支持当前浏览器的选择器；findChild和findChildren则寻找参数下的孩子（们），只支持name</span>
  </li>
  <li>
    <a href="dom.html" title="dom">侦听操作DOM</a>
    <span>当渲染完毕时，自定义组件拥有element对象指向其根节点DOM，即render()方法的根节点</span>
  </li>
  <li>
    <a href="pt.html" title="parent&top">parent&top</a>
    <span>VirtualDom和Component都拥有parent&top引用，可访问父级和最近的顶级组件</span>
  </li>
  <li>
    <a href="ref.html" title="ref">ref引用</a>
    <span>组件还可以通过ref快速访问VirtualDom的引用</span>
  </li>
  <li>
    <a href="event.html" title="event">事件绑定</a>
    <span>vd或组件采用onxxx（忽略大小写）语法绑定事件，并且this指向当前对象，回调参数分别为标准event、绑定vd、触发vd；示例中有个活用bind更改this的示范</span>
  </li>
  <li>
    <a href="delegate.html" title="delegate">事件代理</a>
    <span>你可能想采用类似jquery的on或delegate来提升事件性能，migi也实现了类似功能，并且采用类似选择器预编译解析的方式使得体积和性能都提升很多</span>
  </li>
  <li>
    <a href="unidirectional.html" title="unidirectional">get/set单向数据绑定</a>
    <span>自定义组件类中声明了get/set方法的变量，同时用@bind注解了set的话，在render()中渲染将产生数据绑定，一旦发生改变，会联动</span>
  </li>
  <li>
    <a href="ad.html" title="ad">@bind注解简写语法</a>
    <span>特别的，对于@bind注解绑定的变量，可以使用简化语法避免过多的代码，它会生成等效的get/set方法，内部变量名追加双下划线__来保存</span>
  </li>
  <li>
    <a href="bidirectional.html" title="bidirectional">get/set双向数据绑定</a>
    <span>同上，只是view层发生改变时model层同步</span>
  </li>
  <li>
    <a href="explicit.html" title="explicit">显式声明绑定</a>
    <span>可能有get没set或者mv和m层数据分开的原因，可用为get方法添加@link注解，显示声明绑定哪个变量，其接收绑定变量名参数</span>
  </li>
  <li>
    <a href="bindproperty.html" title="bindproperty">绑定组件属性</a>
    <span>当出现组件嵌套时，父组件的值和子组件的属性可以绑定联动</span>
  </li>
  <li>
    <a href="texta.html" title="texta">文字动画</a>
    <span>展示了如何用数据绑定来实现动画的效果</span>
  </li>
  <li>
    <a href="data.html" title="DATA事件">DATA事件</a>
    <span>当@bind注解绑定的变量发生改变时，会触发Event.DATA事件，它有2个参数：改变的变量名和变量值</span>
  </li>
  <li>
    <a href="cache.html" title="cache">继承缓存组件</a>
    <span>绑定数据频繁操作时会引发大量重绘，此时继承CacheComponent是个很好的选择，它将缓存结果在短时间内只渲染1次</span>
  </li>
  <li>
    <a href="flush.html" title="flush">清空缓存</a>
    <span>如果有特定需求，想对缓存数据渲染进行同步调用，可以使用flush()方法</span>
  </li>
  <li>
    <a href="custom_event.html" title="custom_event">自定义事件</a>
    <span>组件既可侦听dom事件，也可以侦听自定义事件，区别在于on和on-的标签语法；dom事件不区分大小写，自定义事件却区分</span>
  </li>
  <li>
    <a href="expr.html" title="expr">任意js表达式数据都被侦听</a>
    <span>jsx中的js表达式包含的绑定变量可能不止1个，只要涉及到变更都会侦听更新</span>
  </li>
  <li>
    <a href="arrow.html" title="arrowFunction">智能优化侦听变更</a>
    <span>当@bind注解绑定的变量发生改变时，对于render()方法中使用当前context引用的侦听变量（this.{@bind})，会智能分析是否使用并发生改变，然后进行diff，无需手动优化，即没有类似shouldComponentUpdate的东西</span>
  </li>
  <li>
    <a href="optimize.html" title="optimize">更高级的优化和双向绑定</a>
    <span>migi配合预编译器lefty在优化上做了更多，只要context保持，在递归的箭头函数或侦听表达式中，亦进行了优化diff和双向绑定</span>
  </li>
  <li>
    <a href="arr.html" title="arr">侦听数组</a>
    <span>对于数组的一些常用操作方法，进行了侦听，使得数组更新可以做到</span>
  </li>
  <li>
    <a href="add.html" title="add">添加删除元素</a>
    <span>演示了各种情况，更新DOM和文本节点。@bind变量是个数组时，其修改方法（push/pop等）也会侦听</span>
  </li>
  <li>
    <a href="domdiff.html" title="domdiff">DomDiff</a>
    <span>利用虚拟DOM比对来提升性能</span>
  </li>
  <li>
    <a href="range.html" title="range">虚拟range</a>
    <span>除了虚拟dom，还有虚拟range。它避免了为了domDiff方便，将文本用span或者注释节点包括，无任何添加副作用</span>
  </li>
  <li>
    <a href="switch.html" title="switch">切换按钮</a>
    <span>一个Switch的示例</span>
  </li>
  <li>
    <a href="style.html" title="style">css组件</a>
    <span>将Switch用到的css用jaw解析进来形成单一静态资源文件</span>
  </li>
  <li>
    <a href="pseudo.html" title="pseudo">伪类</a>
    <span>也支持css2的伪类</span>
  </li>
  <li>
    <a href="attr.html" title="attr">属性</a>
    <span>也支持css2的属性，建议组件使用单层级class，从性能上考虑</span>
  </li>
  <li>
    <a href="media.html" title="media">媒体查询</a>
    <span>甚至支持部分媒体查询特性（高、宽、像素比、屏幕高宽、屏幕像素比）</span>
  </li>
  <li>
    <a href="exclusive.html" title="exclusive">不排他</a>
    <span>自定义组件示例对象可以单独使用，作为一个普通js对象</span>
  </li>
  <li>
    <a href="select.html" title="select">下拉菜单</a>
    <span>这是一个模拟下拉菜单的组件，它通过前面的Ajax组件读取一个数据源并进行展示</span>
  </li>
  <li>
    <a href="model.html" title="model">Model数据模型</a>
    <span>可以为组件赋值model属性为一个数据模型对象，这样更有利于专门的数据管理，它也可以通过model标签赋值给组件</span>
  </li>
  <li>
    <a href="models.html" title="models">共用Model</a>
    <span>任意多个组件，可共享一个Model对象，如此实现多个组件一份数据</span>
  </li>
  <li>
    <a href="ad2.html" title="ad2">model@bind注解简写语法</a>
    <span>对于Model，@bind简写同样适用</span>
  </li>
  <li>
    <a href="tap.html" title="tap">tap事件</a>
    <span>类似zepto的tap事件，实际上是转换成click</span>
  </li>
  <li>
    <a href="touch.html" title="touch">基本touch手势</a>
    <span>改写自zepto的touch库，内置了doubleTap、longTap、swipe、swipeUp、swipeRight、swipeDown、swipeLeft事件</span>
  </li>
  <li>
    <a href="page.html" title="page">翻页组件</a>
    <span>一个综合的例子，体现了migi的数据绑定、css组件、shadowDom、单一静态资源文件、事件侦听代理、手势等特性</span>
  </li>
  <li>
    <a href="pre.html" title="pre">预渲染</a>
    <span>预渲染也叫服务器端渲染，即通过preRender接口预输出vd为html字符串，再通过preExist实例化vd，注意执行顺序严格保持一致。实际就是将原本的render接口一分为二，提前执行一部分。</span>
  </li>
  <li>
    <a href="benchmark.html" title="benchmark">性能测试</a>
    <span><a href="http://leeluolee.github.io/js-repaint-perfs/" target="_blank">http://leeluolee.github.io/js-repaint-perfs/</a></span>
  </li>
</ol>
<p><a href="https://github.com/migijs/migi" target="_blank" title="github">github source</a></p>
</body>
</html>